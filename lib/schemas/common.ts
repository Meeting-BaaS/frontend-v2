import {
  array,
  iso,
  literal,
  number,
  object,
  type output,
  preprocess,
  string,
  union,
  uuid,
  type ZodTypeAny,
  null as zodNull,
} from "zod";

export const slugSchema = uuid();

export const slugRequestParamsSchema = object({
  slug: slugSchema,
});

export type SlugRequestParams = output<typeof slugRequestParamsSchema>;
export type Slug = output<typeof slugSchema>;

/**
 * Schema for API error response details
 */
const errorDetailItemSchema = object({
  field: string(),
  message: string(),
  code: string(),
});

/**
 * Schema for API error responses
 */
export const errorResponseSchema = object({
  success: literal(false),
  error: string(),
  code: string(),
  statusCode: number().int().positive().optional().nullable(),
  message: string().nullable().optional(),
  details: union([
    string(),
    array(errorDetailItemSchema),
    zodNull(),
  ]).optional(),
});

export type ErrorResponse = output<typeof errorResponseSchema>;

export function integerPreprocess<T extends ZodTypeAny>(schema: T) {
  return preprocess((value) => {
    // Convert null to undefined so .default() will apply
    if (value === null || value === undefined) {
      return undefined;
    }
    if (typeof value === "string") {
      // Handle empty string
      if (value === "") {
        return undefined;
      }
      const parsed = Number.parseInt(value, 10);
      return Number.isNaN(parsed) ? undefined : parsed;
    }
    if (typeof value === "number") {
      return value;
    }
    return undefined;
  }, schema);
}

export const CursorSchema = string()
  .nullable()
  .default(null)
  .refine(
    (value) => {
      if (value == null || value === "") return true; // null/empty is valid

      try {
        // Check for "-" prefix indicating backward pagination
        const isPrevDirection = value.startsWith("-");
        const cursorValue = isPrevDirection ? value.slice(1) : value;

        const decoded = Buffer.from(cursorValue, "base64").toString("utf8");
        const parts = decoded.split("::");
        if (parts.length !== 2 || !parts[0] || !parts[1]) {
          return false;
        }

        // Validate the decoded values
        const createdAt = parts[0];
        const id = Number.parseInt(parts[1], 10);

        // Validate date format
        if (!iso.datetime().safeParse(createdAt).success) {
          return false;
        }

        // Validate id is a positive integer
        if (Number.isNaN(id) || id <= 0) {
          return false;
        }

        return true;
      } catch {
        return false;
      }
    },
    {
      message:
        "Invalid cursor format. Must be a valid base64-encoded cursor generated by the API.",
    },
  );
